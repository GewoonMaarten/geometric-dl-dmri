:py:mod:`loss`
==============

.. py:module:: loss


Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   loss.MSESignal




.. py:class:: MSESignal(sh_order, gradients, no_average=False)

   Bases: :py:obj:`torch.nn.modules.loss._Loss`

   MSESignal(output, label, mask) -> loss

   calculates the MSE for a spherical signal given in spherical harmonic domain in signal domain.

   Args:
       output  (tensor, float): networks output tensor
               (batchsize x number of shells * number of gradients x dim_x x dim_y x dim_z)
       label   (tensor, float): given label tensor
               (batchsize x number of shells * number of gradients x dim_x x dim_y x dim_z)
       mask    (tensor, long): binary mask for with given evaluation mask (e.g. white matter only)
               (batchsize x dim_x x dim_y x dim_z)
   Example::

       loss = MSESignal(sh_order=4, gradient=np.ones((30, 3)))

       output = torch.zeros((128, 15*3, 5, 5, 5))
       label = torch.ones((128, 15*3, 5, 5, 5))
       mask = torch.ones((128, 5, 5, 5)).long()
       loss(output, label, mask)

   .. py:method:: forward(self, output, label, mask)



