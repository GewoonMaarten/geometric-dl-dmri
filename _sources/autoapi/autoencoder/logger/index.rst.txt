:py:mod:`autoencoder.logger`
============================

.. py:module:: autoencoder.logger

.. autoapi-nested-parse::

   Logging levels:
   CRITICAL    50
   ERROR       40
   WARNING     30
   INFO        20
   DEBUG       10
   NOTSET      0



Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   autoencoder.logger.BraceString
   autoencoder.logger.StyleAdapter
   autoencoder.logger.ColorFormatter



Functions
~~~~~~~~~

.. autoapisummary::

   autoencoder.logger.get_logger
   autoencoder.logger.set_log_level



Attributes
~~~~~~~~~~

.. autoapisummary::

   autoencoder.logger.LOGGER_NAME
   autoencoder.logger.FORMATTER
   autoencoder.logger.logger


.. py:data:: LOGGER_NAME
   :annotation: = MUDI

   

.. py:data:: FORMATTER
   :annotation: = %(asctime)s - %(name)s - %(levelname)s - %(message)s (%(filename)s:%(lineno)d)

   

.. py:class:: BraceString

   Bases: :py:obj:`str`

   Initialize self.  See help(type(self)) for accurate signature.

   .. py:method:: __mod__(self, other)

      Return self%value.


   .. py:method:: __str__(self)

      Return str(self).



.. py:class:: StyleAdapter(logger, extra=None)

   Bases: :py:obj:`logging.LoggerAdapter`

   Initialize the adapter with a logger and a dict-like object which
   provides contextual information. This constructor signature allows
   easy stacking of LoggerAdapters, if so desired.

   You can effectively pass keyword arguments as shown in the
   following example:

   adapter = LoggerAdapter(someLogger, dict(p1=v1, p2="v2"))

   .. py:method:: process(self, msg, kwargs)

      Process the logging message and keyword arguments passed in to
      a logging call to insert contextual information. You can either
      manipulate the message itself, the keyword args or both. Return
      the message and kwargs modified (or not) to suit your needs.

      Normally, you'll only need to override this one method in a
      LoggerAdapter subclass for your specific needs.



.. py:class:: ColorFormatter(fmt=None, datefmt=None, style='%', validate=True, *, defaults=None)

   Bases: :py:obj:`logging.Formatter`

   Initialize the formatter with specified format strings.

   Initialize the formatter either with the specified format string, or a
   default as described above. Allow for specialized date formatting with
   the optional datefmt argument. If datefmt is omitted, you get an
   ISO8601-like (or RFC 3339-like) format.

   Use a style parameter of '%', '{' or '$' to specify that you want to
   use one of %-formatting, :meth:`str.format` (``{}``) formatting or
   :class:`string.Template` formatting in your format string.

   .. versionchanged:: 3.2
      Added the ``style`` parameter.

   .. py:attribute:: grey
      :annotation: = [38;21m

      

   .. py:attribute:: yellow
      :annotation: = [33;21m

      

   .. py:attribute:: red
      :annotation: = [31;21m

      

   .. py:attribute:: bold_red
      :annotation: = [31;1m

      

   .. py:attribute:: reset
      :annotation: = [0m

      

   .. py:attribute:: FORMATS
      

      

   .. py:method:: format(self, record)

      Format the specified record as text.

      The record's attribute dictionary is used as the operand to a
      string formatting operation which yields the returned string.
      Before formatting the dictionary, a couple of preparatory steps
      are carried out. The message attribute of the record is computed
      using LogRecord.getMessage(). If the formatting string uses the
      time (as determined by a call to usesTime(), formatTime() is
      called to format the event time. If there is exception information,
      it is formatted using formatException() and appended to the message.



.. py:function:: get_logger()

   Create a logger with a stream handler and a file handler


.. py:function:: set_log_level(log_level)


.. py:data:: logger
   

   

