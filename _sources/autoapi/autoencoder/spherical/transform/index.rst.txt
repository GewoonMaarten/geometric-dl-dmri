:py:mod:`autoencoder.spherical.transform`
=========================================

.. py:module:: autoencoder.spherical.transform


Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   autoencoder.spherical.transform.SignalToS2
   autoencoder.spherical.transform.S2ToSignal
   autoencoder.spherical.transform.SO3ToSignal



Functions
~~~~~~~~~

.. autoapisummary::

   autoencoder.spherical.transform.group_b_values
   autoencoder.spherical.transform.group_te_ti_b_values



.. py:function:: group_b_values(gradients, parameters, b_s, ti_idx = 0, te_idx = 0, data_grouped = None, data = None)

   Group DWI gradients by b-values and returns the grouped gradient directions.
   This function is necessary for the S^2 fourier transforms.

   :param gradients: empty numpy array to store gradients of shape: {TI, TE, b-value, gradient directions, xyz}. The
                     gradient direction dimension can be an arbitrary value as it will be resized in this function.
   :param parameters: ungrouped gradient directions.
   :param b_s: all unique b-values.
   :param ti_idx: TI index of the ``gradients`` attribute. Defaults to 0.
   :param te_idx: TE index of the ``gradients`` attribute. Defaults to 0.
   :param data_grouped: empty numpy array to store grouped data in. Defaults to None
   :param data: Optional data to group. Defaults to None.

   :returns: grouped gradient directions of shape {TI, TE, b-value, gradient directions, xyz} and grouped data of
             shape {batch size, TI, TE, gradient directions, b-values}


.. py:function:: group_te_ti_b_values(parameters, data = None)

   Group DWI gradient direction by b-values and TI and TE parameters if applicable.
   This function is necessary for the S^2 fourier transforms.

   :param parameters: ungrouped gradients directions.
   :param data: Optional data to group. Defaults to None.

   :returns: grouped gradient directions of shape {TI, TE, b-value, gradient directions, xyz} and optionally grouped data of
             shape {batch size, TI, TE, gradient directions, b-values}


.. py:class:: SignalToS2(gradients, sh_degree_max, inversion_function, **kwargs)

   Bases: :py:obj:`torch.nn.Module`

   Computes the spherical harmonic coefficients.
   According to:

   .. math::

       \hat{s}^m_l = \int_{S^2} s(r) \overline{Y^m_l(r)} dr

   where :math:`\hat{s}^m_l` are the spherical coefficients, :math:`r \in \mathbb{R}^3`,
   :math:`s : S^2 \mapsto \mathbb{C}` and :math:`\overline{Y^m_l(r)}` denotes the `spherical harmonics`_, the
   overbar denotes the `complex conjugation`_.

   See "Spherical CNNs" by T. Cohen `et al.` for more information :cite:p:`cohen2018spherical`.

   Example usage:

   .. code-block:: python
       :linenos:

       # Create random dwi data with 90 gradient directions and 4 b-values
       gradients = torch.rand((1,1,4, 90, 3)) # {TI, TE, b-values, gradients, xyz}
       data = torch.rand((1,1,512, 90, 4)) # {TI, TE, batch size, gradients, b-values}

       signal_to_s2 = SignalToS2(gradients, 4, "gram_schmidt")
       signal_to_s2(data)

   :param gradients: Vectors to fit the Spherical Harmonics to. Has to be of shape ``(TI, TE, a, b, 3)``, where
                     ``a`` are the number of b-values (shells) and ``b`` is the number of gradient directions. The vector is
                     in cartesian coordinates (xyz).
   :param sh_degree_max: Maximum degree (``l``) of Spherical Harmonics to fit. Denoted by :math:`L_{max}` in the
                         equation.
   :param inversion_function: name of the inversion function to apply. Available functions are:

                              - ``"lms"`` = :func:`lms_sh_inv`
                              - ``"lms_tikhonov"`` = :func:`lms_tikhonov_sh_inv`
                              - ``"lms_laplace_beltrami"`` = :func:`lms_laplace_beltrami_sh_inv`
                              - ``"gram_schmidt"`` = :func:`gram_schmidt_sh_inv`

   :raises ValueError: raised when an unknown inversion function is given.

   .. _spherical harmonics: https://en.wikipedia.org/wiki/Spherical_harmonics
   .. _complex conjugation: https://en.wikipedia.org/wiki/Complex_conjugate

   .. py:method:: n_sh(self)
      :property:


   .. py:method:: forward(self, x)


   .. py:method:: lms_sh_inv(self, sh, l_max, **kwargs)

      Inversion of spherical harmonic basis with least-mean square

      :param sh: real spherical harmonics bases of even degree (each column is a basis)
      :param l_max: spherical harmonics degree

      :returns: inverted spherical harmonic bases of even degree


   .. py:method:: lms_tikhonov_sh_inv(self, sh, l_max, **kwargs)

      Inversion of spherical harmonic basis with least-mean square regularized with Tikhonov regularization term :cite:p:`hess2006q`

      :param sh: real spherical harmonics bases of even degree (each column is a basis)
      :param l_max: spherical harmonics degree
      :param \*\*lambda_: regularization weight. Defaults to 0.006
      :type \*\*lambda_: float

      :returns: inverted spherical harmonic bases of even degree


   .. py:method:: lms_laplace_beltrami_sh_inv(self, sh, l_max, **kwargs)

      Inversion of spherical harmonic basis with least-mean square regularized with Laplace-Beltrami regularization term :cite:p:`descoteaux2007regularized`

      :param sh: real spherical harmonics bases of even degree (each column is a basis)
      :param l_max: spherical harmonics degree
      :param \*\*lambda_: regularization weight. Defaults to 0.006
      :type \*\*lambda_: float

      :returns: inverted spherical harmonic bases of even degree


   .. py:method:: gram_schmidt_sh_inv(self, sh, l_max, **kwargs)

      Inversion of spherical harmonic basis with Gram-Schmidt orthonormalization process :cite:p:`yeo2005computing`

      :param sh: real spherical harmonics bases of even degree (each column is a basis)
      :param l_max: spherical harmonics degree
      :param \*\*n_iter: number of iterations for degree shuffling. Defaults to 1000
      :type \*\*n_iter: int

      :returns: inverted spherical harmonic bases of even degree



.. py:class:: S2ToSignal(gradients, sh_degree_max)

   Bases: :py:obj:`torch.nn.Module`

   Computes the DWI from the spherical harmonic coefficients.
   According to:

   .. math::

       s(r) = \sum^{L_{max}}_{l=0} \sum^{m=l}_{m=-l} \hat{s}^m_l Y^m_l(r)

   where :math:`s(r)` is the DWI signal, :math:`r \in \mathbb{R}^3`,
   :math:`Y^m_l(r)` denotes the `spherical harmonics`_ and :math:`\hat{s}^m_l` are the spherical coefficients.

   See "Spherical CNNs" by T. Cohen `et al.` for more information :cite:p:`cohen2018spherical`.

   Example usage:

   .. code-block:: python
       :linenos:

       # Create random sh coefficients with 90 gradient directions and 4 b-values
       gradients = torch.rand((4, 90, 3)) # {b-values, gradients, xyz}
       data = torch.rand((512, 90, 4)) # {batch size, gradients, SH coefficients}

       s2_to_signal = S2ToSignal(gradients, 4)
       s2_to_signal(data)

   :param gradients: Vectors to fit the Spherical Harmonics to. Has to be of shape ``(TI, TE, a, b, 3)``, where
                     ``a`` are the number of b-values (shells) and ``b`` is the number of gradient directions. The vector is
                     in cartesian coordinates (xyz).
   :param sh_degree_max: Maximum degree (``l``) of Spherical Harmonics to fit. Denoted by :math:`L_{max}` in the
                         equation.

   .. _spherical harmonics: https://en.wikipedia.org/wiki/Spherical_harmonics

   .. py:method:: n_sh(self)
      :property:


   .. py:method:: forward(self, x)



.. py:class:: SO3ToSignal(gradients, sh_degree_max)

   Bases: :py:obj:`torch.nn.Module`

   Computes the DWI from the Wigner-D matrix coefficients.
   Every coefficient in the `Wigner-D matrix`_ where :math:`m != 0` are thrown away, leaving us with the
   spherical harmonic coefficients. More formally:

   .. math::

       Y_l^n(r) = D_l^{m=0,n}(R)

   After this, the same steps are used as in :class:`.S2ToSignal`.

   Example usage:

   .. code-block:: python
       :linenos:

       gradients = torch.rand((4, 90, 3)) # {b-values, gradients, xyz}
       data = {
           0: torch.rand((512, 90, 1, 1)), # {batch size, gradients, Wigner-D coefficients, Wigner-D coefficients}
           2: torch.rand((512, 90, 5, 5)),
           4: torch.rand((512, 90, 9, 9))
       } # data is expected to be a dict where each key is a sh degree.

       so3_to_signal = SO3ToSignal(gradients, 4)
       so3_to_signal(data)

   :param gradients: Vectors to fit the Spherical Harmonics to. Has to be of shape ``(a,b,3)``, where
                     ``a`` are the number of b-values (shells) and ``b`` is the number of gradient directions. The vector is
                     in cartesian coordinates (xyz).
   :param sh_degree_max: Maximum degree of Spherical Harmonics to fit.

   .. _Wigner-D matrix: https://en.wikipedia.org/wiki/Wigner_D-matrix

   .. py:method:: forward(self, x)



